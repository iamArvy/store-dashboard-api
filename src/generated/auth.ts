// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.21.12
// source: auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "auth";

export interface Status {
  success: boolean;
}

export interface UpdatePasswordInput {
  id: string;
  oldPassword: string;
  newPassword: string;
}

export interface UpdateEmailInput {
  id: string;
  email: string;
}

export interface UserRoleInput {
  userId: string;
  roleId: string;
}

export interface HealthCheckResponse {
  status: string;
  timestamp: string;
}

export interface Token {
  token: string;
  expiresIn: number;
}

export interface AuthInput {
  email: string;
  password: string;
}

export interface AuthResponse {
  access: Token | undefined;
  refresh: Token | undefined;
}

export interface Role {
  id: string;
  name: string;
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface RoleList {
  roles: Role[];
}

export interface RoleById {
  id: string;
}

export interface RoleByName {
  name: string;
}

export interface RoleInput {
  name: string;
  description: string;
}

export const AUTH_PACKAGE_NAME = "auth";

function createBaseStatus(): Status {
  return { success: false };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePasswordInput(): UpdatePasswordInput {
  return { id: "", oldPassword: "", newPassword: "" };
}

export const UpdatePasswordInput: MessageFns<UpdatePasswordInput> = {
  encode(message: UpdatePasswordInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePasswordInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePasswordInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateEmailInput(): UpdateEmailInput {
  return { id: "", email: "" };
}

export const UpdateEmailInput: MessageFns<UpdateEmailInput> = {
  encode(message: UpdateEmailInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEmailInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEmailInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUserRoleInput(): UserRoleInput {
  return { userId: "", roleId: "" };
}

export const UserRoleInput: MessageFns<UserRoleInput> = {
  encode(message: UserRoleInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.roleId !== "") {
      writer.uint32(18).string(message.roleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRoleInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRoleInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "", timestamp: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseToken(): Token {
  return { token: "", expiresIn: 0 };
}

export const Token: MessageFns<Token> = {
  encode(message: Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expiresIn !== 0) {
      writer.uint32(16).int32(message.expiresIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresIn = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthInput(): AuthInput {
  return { email: "", password: "" };
}

export const AuthInput: MessageFns<AuthInput> = {
  encode(message: AuthInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseAuthResponse(): AuthResponse {
  return { access: undefined, refresh: undefined };
}

export const AuthResponse: MessageFns<AuthResponse> = {
  encode(message: AuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access !== undefined) {
      Token.encode(message.access, writer.uint32(10).fork()).join();
    }
    if (message.refresh !== undefined) {
      Token.encode(message.refresh, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access = Token.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refresh = Token.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRole(): Role {
  return { id: "", name: "", description: "", createdAt: "", updatedAt: "" };
}

export const Role: MessageFns<Role> = {
  encode(message: Role, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(42).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Role {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRoleList(): RoleList {
  return { roles: [] };
}

export const RoleList: MessageFns<RoleList> = {
  encode(message: RoleList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRoleById(): RoleById {
  return { id: "" };
}

export const RoleById: MessageFns<RoleById> = {
  encode(message: RoleById, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleById {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRoleByName(): RoleByName {
  return { name: "" };
}

export const RoleByName: MessageFns<RoleByName> = {
  encode(message: RoleByName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleByName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleByName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseRoleInput(): RoleInput {
  return { name: "", description: "" };
}

export const RoleInput: MessageFns<RoleInput> = {
  encode(message: RoleInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface AuthServiceClient {
  health(request: Empty): Observable<HealthCheckResponse>;

  register(request: AuthInput): Observable<AuthResponse>;

  login(request: AuthInput): Observable<AuthResponse>;
}

export interface AuthServiceController {
  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;

  register(request: AuthInput): Promise<AuthResponse> | Observable<AuthResponse> | AuthResponse;

  login(request: AuthInput): Promise<AuthResponse> | Observable<AuthResponse> | AuthResponse;
}

export function AuthServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["health", "register", "login"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUTH_SERVICE_NAME = "AuthService";

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  health: {
    path: "/auth.AuthService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  register: {
    path: "/auth.AuthService/register",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuthInput) => Buffer.from(AuthInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuthInput.decode(value),
    responseSerialize: (value: AuthResponse) => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthResponse.decode(value),
  },
  login: {
    path: "/auth.AuthService/login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AuthInput) => Buffer.from(AuthInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AuthInput.decode(value),
    responseSerialize: (value: AuthResponse) => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  health: handleUnaryCall<Empty, HealthCheckResponse>;
  register: handleUnaryCall<AuthInput, AuthResponse>;
  login: handleUnaryCall<AuthInput, AuthResponse>;
}

export interface RoleServiceClient {
  create(request: RoleInput): Observable<HealthCheckResponse>;

  roles(request: Empty): Observable<RoleList>;

  roleById(request: RoleById): Observable<Role>;

  roleByName(request: RoleByName): Observable<Role>;

  /** rpc update (RoleInput) returns (AuthResponse) {} */

  delete(request: RoleById): Observable<Status>;

  health(request: Empty): Observable<HealthCheckResponse>;
}

export interface RoleServiceController {
  create(request: RoleInput): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;

  roles(request: Empty): Promise<RoleList> | Observable<RoleList> | RoleList;

  roleById(request: RoleById): Promise<Role> | Observable<Role> | Role;

  roleByName(request: RoleByName): Promise<Role> | Observable<Role> | Role;

  /** rpc update (RoleInput) returns (AuthResponse) {} */

  delete(request: RoleById): Promise<Status> | Observable<Status> | Status;

  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function RoleServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["create", "roles", "roleById", "roleByName", "delete", "health"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("RoleService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("RoleService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ROLE_SERVICE_NAME = "RoleService";

export type RoleServiceService = typeof RoleServiceService;
export const RoleServiceService = {
  create: {
    path: "/auth.RoleService/create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RoleInput) => Buffer.from(RoleInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RoleInput.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  roles: {
    path: "/auth.RoleService/roles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: RoleList) => Buffer.from(RoleList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RoleList.decode(value),
  },
  roleById: {
    path: "/auth.RoleService/roleById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RoleById) => Buffer.from(RoleById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RoleById.decode(value),
    responseSerialize: (value: Role) => Buffer.from(Role.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Role.decode(value),
  },
  roleByName: {
    path: "/auth.RoleService/roleByName",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RoleByName) => Buffer.from(RoleByName.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RoleByName.decode(value),
    responseSerialize: (value: Role) => Buffer.from(Role.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Role.decode(value),
  },
  /** rpc update (RoleInput) returns (AuthResponse) {} */
  delete: {
    path: "/auth.RoleService/delete",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RoleById) => Buffer.from(RoleById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RoleById.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  health: {
    path: "/auth.RoleService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface RoleServiceServer extends UntypedServiceImplementation {
  create: handleUnaryCall<RoleInput, HealthCheckResponse>;
  roles: handleUnaryCall<Empty, RoleList>;
  roleById: handleUnaryCall<RoleById, Role>;
  roleByName: handleUnaryCall<RoleByName, Role>;
  /** rpc update (RoleInput) returns (AuthResponse) {} */
  delete: handleUnaryCall<RoleById, Status>;
  health: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface UserServiceClient {
  updatePassword(request: UpdatePasswordInput): Observable<Status>;

  updateEmail(request: UpdateEmailInput): Observable<Status>;

  assignRole(request: UserRoleInput): Observable<Status>;

  removeRole(request: UserRoleInput): Observable<Status>;

  health(request: Empty): Observable<HealthCheckResponse>;
}

export interface UserServiceController {
  updatePassword(request: UpdatePasswordInput): Promise<Status> | Observable<Status> | Status;

  updateEmail(request: UpdateEmailInput): Promise<Status> | Observable<Status> | Status;

  assignRole(request: UserRoleInput): Promise<Status> | Observable<Status> | Status;

  removeRole(request: UserRoleInput): Promise<Status> | Observable<Status> | Status;

  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;
}

export function UserServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["updatePassword", "updateEmail", "assignRole", "removeRole", "health"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("UserService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("UserService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const USER_SERVICE_NAME = "UserService";

export type UserServiceService = typeof UserServiceService;
export const UserServiceService = {
  updatePassword: {
    path: "/auth.UserService/updatePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePasswordInput) => Buffer.from(UpdatePasswordInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdatePasswordInput.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  updateEmail: {
    path: "/auth.UserService/updateEmail",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateEmailInput) => Buffer.from(UpdateEmailInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateEmailInput.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  assignRole: {
    path: "/auth.UserService/assignRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserRoleInput) => Buffer.from(UserRoleInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserRoleInput.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  removeRole: {
    path: "/auth.UserService/removeRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UserRoleInput) => Buffer.from(UserRoleInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UserRoleInput.decode(value),
    responseSerialize: (value: Status) => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Status.decode(value),
  },
  health: {
    path: "/auth.UserService/health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface UserServiceServer extends UntypedServiceImplementation {
  updatePassword: handleUnaryCall<UpdatePasswordInput, Status>;
  updateEmail: handleUnaryCall<UpdateEmailInput, Status>;
  assignRole: handleUnaryCall<UserRoleInput, Status>;
  removeRole: handleUnaryCall<UserRoleInput, Status>;
  health: handleUnaryCall<Empty, HealthCheckResponse>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
