// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v3.21.12
// source: store.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "store";

export interface HealthCheckResponse {
  status: string;
}

export interface StoreById {
  id: string;
}

export interface Store {
  id: string;
  name: string;
  description: string;
  location: string;
  website: string;
  phone: string;
  email: string;
  ownerId: string;
  /** active, inactive, pending */
  status: string;
  createdAt: string;
  updatedAt: string;
  deletedAt: string;
  /** URL to the store's logo */
  logoUrl: string;
}

export interface StoreList {
  stores: Store[];
}

export interface StoreByName {
  name: string;
}

export interface StoreInput {
  name: string;
}

export interface StoreData {
  name: string;
  description?: string | undefined;
  location?: string | undefined;
  website?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export interface PartialStoreData {
  name?: string | undefined;
  description?: string | undefined;
  location?: string | undefined;
  website?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
}

export interface CreateStoreInput {
  ownerId: string;
  data: StoreData | undefined;
}

export interface UpdateStoreInput {
  ownerId: string;
  data: PartialStoreData | undefined;
}

export const STORE_PACKAGE_NAME = "store";

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreById(): StoreById {
  return { id: "" };
}

export const StoreById: MessageFns<StoreById> = {
  encode(message: StoreById, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreById {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStore(): Store {
  return {
    id: "",
    name: "",
    description: "",
    location: "",
    website: "",
    phone: "",
    email: "",
    ownerId: "",
    status: "",
    createdAt: "",
    updatedAt: "",
    deletedAt: "",
    logoUrl: "",
  };
}

export const Store: MessageFns<Store> = {
  encode(message: Store, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    if (message.website !== "") {
      writer.uint32(42).string(message.website);
    }
    if (message.phone !== "") {
      writer.uint32(50).string(message.phone);
    }
    if (message.email !== "") {
      writer.uint32(58).string(message.email);
    }
    if (message.ownerId !== "") {
      writer.uint32(66).string(message.ownerId);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(90).string(message.updatedAt);
    }
    if (message.deletedAt !== "") {
      writer.uint32(98).string(message.deletedAt);
    }
    if (message.logoUrl !== "") {
      writer.uint32(106).string(message.logoUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Store {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.deletedAt = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.logoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreList(): StoreList {
  return { stores: [] };
}

export const StoreList: MessageFns<StoreList> = {
  encode(message: StoreList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stores) {
      Store.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stores.push(Store.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreByName(): StoreByName {
  return { name: "" };
}

export const StoreByName: MessageFns<StoreByName> = {
  encode(message: StoreByName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreByName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreByName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreInput(): StoreInput {
  return { name: "" };
}

export const StoreInput: MessageFns<StoreInput> = {
  encode(message: StoreInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseStoreData(): StoreData {
  return { name: "" };
}

export const StoreData: MessageFns<StoreData> = {
  encode(message: StoreData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.location !== undefined) {
      writer.uint32(26).string(message.location);
    }
    if (message.website !== undefined) {
      writer.uint32(34).string(message.website);
    }
    if (message.phone !== undefined) {
      writer.uint32(42).string(message.phone);
    }
    if (message.email !== undefined) {
      writer.uint32(50).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePartialStoreData(): PartialStoreData {
  return {};
}

export const PartialStoreData: MessageFns<PartialStoreData> = {
  encode(message: PartialStoreData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.location !== undefined) {
      writer.uint32(26).string(message.location);
    }
    if (message.website !== undefined) {
      writer.uint32(34).string(message.website);
    }
    if (message.phone !== undefined) {
      writer.uint32(42).string(message.phone);
    }
    if (message.email !== undefined) {
      writer.uint32(50).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartialStoreData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartialStoreData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.website = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateStoreInput(): CreateStoreInput {
  return { ownerId: "", data: undefined };
}

export const CreateStoreInput: MessageFns<CreateStoreInput> = {
  encode(message: CreateStoreInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerId !== "") {
      writer.uint32(10).string(message.ownerId);
    }
    if (message.data !== undefined) {
      StoreData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateStoreInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStoreInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = StoreData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateStoreInput(): UpdateStoreInput {
  return { ownerId: "", data: undefined };
}

export const UpdateStoreInput: MessageFns<UpdateStoreInput> = {
  encode(message: UpdateStoreInput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownerId !== "") {
      writer.uint32(10).string(message.ownerId);
    }
    if (message.data !== undefined) {
      PartialStoreData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateStoreInput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateStoreInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = PartialStoreData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface StoreServiceClient {
  health(request: Empty): Observable<HealthCheckResponse>;

  create(request: CreateStoreInput): Observable<Store>;

  getById(request: StoreById): Observable<Store>;

  getByOwner(request: StoreById): Observable<Store>;

  getActive(request: Empty): Observable<StoreList>;

  getInactive(request: Empty): Observable<StoreList>;

  getPending(request: Empty): Observable<StoreList>;

  list(request: Empty): Observable<StoreList>;

  update(request: UpdateStoreInput): Observable<Store>;

  activate(request: StoreById): Observable<Empty>;

  deactivate(request: StoreById): Observable<Empty>;
}

export interface StoreServiceController {
  health(request: Empty): Promise<HealthCheckResponse> | Observable<HealthCheckResponse> | HealthCheckResponse;

  create(request: CreateStoreInput): Promise<Store> | Observable<Store> | Store;

  getById(request: StoreById): Promise<Store> | Observable<Store> | Store;

  getByOwner(request: StoreById): Promise<Store> | Observable<Store> | Store;

  getActive(request: Empty): Promise<StoreList> | Observable<StoreList> | StoreList;

  getInactive(request: Empty): Promise<StoreList> | Observable<StoreList> | StoreList;

  getPending(request: Empty): Promise<StoreList> | Observable<StoreList> | StoreList;

  list(request: Empty): Promise<StoreList> | Observable<StoreList> | StoreList;

  update(request: UpdateStoreInput): Promise<Store> | Observable<Store> | Store;

  activate(request: StoreById): void;

  deactivate(request: StoreById): void;
}

export function StoreServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "health",
      "create",
      "getById",
      "getByOwner",
      "getActive",
      "getInactive",
      "getPending",
      "list",
      "update",
      "activate",
      "deactivate",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("StoreService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("StoreService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const STORE_SERVICE_NAME = "StoreService";

export type StoreServiceService = typeof StoreServiceService;
export const StoreServiceService = {
  health: {
    path: "/store.StoreService/Health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  create: {
    path: "/store.StoreService/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateStoreInput) => Buffer.from(CreateStoreInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateStoreInput.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  getById: {
    path: "/store.StoreService/GetById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  getByOwner: {
    path: "/store.StoreService/GetByOwner",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  getActive: {
    path: "/store.StoreService/GetActive",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  getInactive: {
    path: "/store.StoreService/GetInactive",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  getPending: {
    path: "/store.StoreService/GetPending",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  list: {
    path: "/store.StoreService/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: StoreList) => Buffer.from(StoreList.encode(value).finish()),
    responseDeserialize: (value: Buffer) => StoreList.decode(value),
  },
  update: {
    path: "/store.StoreService/Update",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateStoreInput) => Buffer.from(UpdateStoreInput.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateStoreInput.decode(value),
    responseSerialize: (value: Store) => Buffer.from(Store.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Store.decode(value),
  },
  activate: {
    path: "/store.StoreService/Activate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  deactivate: {
    path: "/store.StoreService/Deactivate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StoreById) => Buffer.from(StoreById.encode(value).finish()),
    requestDeserialize: (value: Buffer) => StoreById.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
} as const;

export interface StoreServiceServer extends UntypedServiceImplementation {
  health: handleUnaryCall<Empty, HealthCheckResponse>;
  create: handleUnaryCall<CreateStoreInput, Store>;
  getById: handleUnaryCall<StoreById, Store>;
  getByOwner: handleUnaryCall<StoreById, Store>;
  getActive: handleUnaryCall<Empty, StoreList>;
  getInactive: handleUnaryCall<Empty, StoreList>;
  getPending: handleUnaryCall<Empty, StoreList>;
  list: handleUnaryCall<Empty, StoreList>;
  update: handleUnaryCall<UpdateStoreInput, Store>;
  activate: handleUnaryCall<StoreById, Empty>;
  deactivate: handleUnaryCall<StoreById, Empty>;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
